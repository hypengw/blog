[{"content":"I got in touch with rust quite early and watched its ecosystem gradually improve.\nWhen I first used trait, I wondered how to implement such a great feature in c++.\nThough it wasn\u0026rsquo;t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.\nRust Trait Let\u0026rsquo;s first look at an example of rust trait.\nSimply put, it\u0026rsquo;s about defining interfaces, implementing interfaces, and interface polymorphism.\nActually, c++ already has a complete inheritance paradigm to implement these requirements - virtual interface, inheritance implementation, virtual polymorphism.\nHowever, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.\nSo let\u0026rsquo;s try to implement trait without using virtual inheritance.\nkeywords trait â†’ Defines a trait. trait Speak { fn speak(\u0026amp;self) -\u0026gt; String; } impl â†’ Implements a trait for a type. struct Dog; impl Speak for Dog { fn speak(\u0026amp;self) -\u0026gt; String { \u0026#34;Woof!\u0026#34;.to_string() } } where â†’ Adds trait bounds in a structured way. fn make_speak\u0026lt;T\u0026gt;(animal: T) where T: Speak { println!(\u0026#34;{}\u0026#34;, animal.speak()); } dyn â†’ Used for dynamic dispatch. fn speak_dyn(animal: \u0026amp;dyn Speak) { println!(\u0026#34;{}\u0026#34;, animal.speak()); } C++ Implementation Complete code The specific implementation may change, refer to the documentation in the repo\nInterface Definition When there\u0026rsquo;s no reflection for code generation, the interface needs to include delegate functionality\nrequires can only be used as constraints; it cannot be materialized into concrete functions, so we need to define concrete interface classes.\nNow we can define any interface class and write a set of function declarations.\nThen how do we call the implementation through the interface? For concrete instances, they should have concrete implementation functions that can be called normally. But considering the implementation of dyn, and that C++ cannot generate variable/function names through templates, I thought about having the interface class carry its own delegate implementation, which calls different implementations based on different situations.\ntemplate\u0026lt;typename T\u0026gt; struct Speak { auto speak() -\u0026gt; std::string { return M::template call\u0026lt;0\u0026gt;(this); } private: using M = TraitMeta\u0026lt;Speak, T\u0026gt;; friend M; template\u0026lt;typename F\u0026gt; static consteval auto collect() { return TraitApi { \u0026amp;F::speak }; } }; template call\u0026lt;X\u0026gt;: Looks up the function in the vtable and then calls it. For vtable, static dispatch references constexpr static variables, while dynamic dispatch references through pointers. collect: Helps to get the type and address of the interface without reflection. Since it\u0026rsquo;s a template, it can also be used to verify if the interface is correctly implemented. TraitApi: Internally, it\u0026rsquo;s a simple tuple that stores type information and addresses. Interface Implementation Common Customization Points in c++ include overloading, template specialization, Policy, and ADL.\nHere we choose template specialization, which is similar to how rust implements it.\nFor example, the Orphan Rule, which is the orphan principle for trait:\nImplement external Trait for your own types Implement your own Trait for external types From the perspective of c++, it\u0026rsquo;s easy to understand that these two rules ensure that the implementation of the Trait (i.e., template specialization) is visible to the compilation unit that references it (i.e., the .cpp/.cc that references the .h).\nThis avoids generating different implementations in different compilation units.\nstruct Dog; template\u0026lt;\u0026gt; struct Impl\u0026lt;Speak, Dog\u0026gt; { static auto speak(TraitPtr self) -\u0026gt; std::string; }; struct Dog : Speak\u0026lt;Dog\u0026gt; { std::string voice {\u0026#34;Woof!\u0026#34;}; }; auto Impl\u0026lt;Speak, Dog\u0026gt;::speak(TraitPtr self) -\u0026gt; std::string { return self.as_ref\u0026lt;Dog\u0026gt;().voice; } ... Impl accepts a Trait template and a concrete type. : Speak\u0026lt;Dog\u0026gt; non-virtual inheritance allows the Dog class to have concrete interface functions, i.e., Dog().speak(). Impl\u0026lt;Speak, Dog\u0026gt;::speak(Dog()) directly calls the implementation. It\u0026rsquo;s better to separate the fields definition of Dog.\nThis way, you can directly operate on Dog fields even when Dog is not yet defined.\nstruct Dog; struct DogFields { std::string voice {\u0026#34;Woof!\u0026#34;}; }; // Impl Speak\u0026lt;Dog\u0026gt; ... struct Dog : DogFields, Speak\u0026lt;Dog\u0026gt; {} Static Dispatch Use std::semiregular to determine if Impl is fully defined, or you can write a template to check the size.\ntemplate\u0026lt;typename A, template\u0026lt;typename\u0026gt; class... T\u0026gt; concept Implemented = (std::semiregular\u0026lt;Impl\u0026lt;T, A\u0026gt;\u0026gt; \u0026amp;\u0026amp; ...); // ... template\u0026lt;typename T\u0026gt; requires Implemented\u0026lt;T, Speak\u0026gt; void make_speak(T\u0026amp; animal) { std::print(\u0026#34;{}\u0026#34;, animal.speak()); } dyn Fat Pointer It stores a vtable pointer and a self pointer.\nThen use the dispatch functionality of the interface class to make the call.\ntemplate\u0026lt;template\u0026lt;typename\u0026gt; class Tr, ConstNess Cn\u0026gt; class Dyn : public Tr\u0026lt;DynImpl\u0026lt;Tr\u0026gt;\u0026gt; { using M = TraitMeta\u0026lt;Tr, DynImpl\u0026lt;Tr\u0026gt;\u0026gt;; friend M; using ptr_t = std::conditional_t\u0026lt;Cn == ConstNess::Const, const TraitPtr, TraitPtr\u0026gt;; const decltype(M::apis)* const apis; ptr_t self; ... } // ... Dog dog; auto dyn = make_dyn\u0026lt;Speak\u0026gt;(dog); std::print(\u0026#34;{}\u0026#34;, dyn.speak()); Tr: A Trait interface Tr\u0026lt;DynImpl\u0026lt;Tr\u0026gt;\u0026gt;: Uses the DynImpl tag to mark Tr, generating concrete call functions apis: vtable pointer Cn: Tr cannot have a const tag, so an additional parameter is needed to mark ConstNess Box dyn TODO\n","permalink":"https://blog.bluempty.com/en/post/cpp-rust-trait/","summary":"\u003cp\u003eI got in touch with \u003ccode\u003erust\u003c/code\u003e quite early and watched its ecosystem gradually improve.\u003cbr\u003e\nWhen I first used \u003ccode\u003etrait\u003c/code\u003e, I wondered how to implement such a great feature in \u003ccode\u003ec++\u003c/code\u003e.\u003cbr\u003e\nThough it wasn\u0026rsquo;t an urgent need, I put it aside. Recently, I tried to implement it in a simple way.\u003c/p\u003e\n\u003ch2 id=\"rust-trait\"\u003eRust Trait\u003c/h2\u003e\n\u003cp\u003eLet\u0026rsquo;s first look at an example of rust trait.\u003cbr\u003e\nSimply put, it\u0026rsquo;s about \u003cem\u003edefining interfaces, implementing interfaces, and interface polymorphism\u003c/em\u003e.\u003cbr\u003e\nActually, \u003ccode\u003ec++\u003c/code\u003e already has a complete inheritance paradigm to implement these requirements - \u003cem\u003evirtual interface, inheritance implementation, virtual polymorphism\u003c/em\u003e.\u003cbr\u003e\nHowever, virtual functions require forced dynamic dispatch and add virtual table pointers to class instances.\u003cbr\u003e\nSo let\u0026rsquo;s try to implement \u003ccode\u003etrait\u003c/code\u003e without using virtual inheritance.\u003c/p\u003e","title":"Simulating Rust Trait in C++"},{"content":" Reading this article requires some understanding of: Linux distributions, Linux Desktop Environment, Package Manager\nMy first encounter with Linux was in high school, when there seemed to be a software that only had a Linux version, so I tried to install Arch by following online articles. I don\u0026rsquo;t remember the specific details anymore. For me at that time, a bunch of incomprehensible commands were quite a headache, and I was always afraid of breaking my computer.\nDuring university, I used a dual-boot system for a while. In daily use, the Linux system was particularly prone to \u0026ldquo;breaking\u0026rdquo;, and the reasons were varied and bizarre. Looking at it layer by layer, hardware compatibility/kernel/drivers/system libraries/dependencies/desktop environment, etc., could all have bugs. These components are also somewhat disconnected from each other, so problems are common. Occasionally solving one or two problems gives a sense of accomplishment, but too many just feel purely troublesome.\nThere\u0026rsquo;s a specific example that made me want to laugh while also relating deeply: Linus Tech uninstalled his desktop environment while trying to install Steam.\nIn 2020, I accidentally came across Flatpak, and within a short time, I went all-in with Flatpak for my daily software. Later, I also maintained several software packages I wanted to use on Flathub. In terms of daily experience, I no longer have to worry about software not working after updates, don\u0026rsquo;t need to manually manage software updates, no longer worry about unruly closed-source software, and no longer worry that system updates will break my main software.\nAfter using Flatpak, I decided to make Linux Desktop my primary system.\nWhat Problems Does Flatpak Solve First and foremost, decoupling from the system. This specifically solves the problem that Linus Tech encountered above. Actually, something similar has existed on servers for quite a while, namely containers, that is, the Docker ecosystem. Friends who have been exposed to Linux distributions should be particularly familiar with package management, along with concepts like dependencies, repositories, source code, packages, FHS, etc., though we won\u0026rsquo;t discuss how this system specifically works here.\nLet\u0026rsquo;s look at how Linus Tech accidentally damaged his desktop environment. The installation command was sudo apt-get install steam, followed by a large output, which included a warning WARNING: The following essential packages will be removed, and this included pop-desktop, which ultimately led to the desktop environment being uninstalled. Some people would point out that this is because Linus Tech was unfamiliar, or that the installation guide and critical package protection weren\u0026rsquo;t handled well, or that it\u0026rsquo;s a problem with package management, or that using Linux as a desktop system is just stupid and deserved.\nLooking beyond the phenomenon to the key issue, first, installing user software requires sudo. There\u0026rsquo;s a good analogy, which is UAC in Windows systems. Friends who frequently use Windows systems must have heard the term reinstalling the system, right? So why do you need to reinstall your system from time to time? A major factor is that most of the software you use daily requests UAC to install or run. To use a car analogy, an originally good car, in order to add certain features, is sent to a modification shop. The shop people can certainly implement this feature, but this doesn\u0026rsquo;t prevent them from installing some extra things on the car or replacing critical parts. After multiple modifications, the car gradually breaks down.\nSecond, apt-get manages both user software and system components simultaneously. In my view, dependency management is a complex system problem. The chaotic dependency relationships between software packages, with each node in the relationship network frequently updating itself, it\u0026rsquo;s not difficult to conclude that the uncertainty here increases nearly exponentially with the number of packages. There\u0026rsquo;s also an example of this: occasionally seeing developers who use npm complaining about node_modules is particularly interesting.\nHere I clearly distinguish between user software and system components. System components are few in number, change slowly and are stable, and are mostly depended upon - these characteristics perfectly fit package management. User software, on the other hand, is numerous and diverse, changes rapidly and can die at any time, depends on a large number of libraries - this completely steps on package management\u0026rsquo;s landmines. When we try to integrate these two types of packages together, system components being \u0026ldquo;blown up\u0026rdquo; by some user software is to be expected.\nSecondly, it introduces sandboxing. There\u0026rsquo;s no need to say much about what problem this solves. In recent years, both Microsoft and Google have been tightening permissions for user software on their respective systems. Users in China are also slowly becoming aware of privacy and security-related concepts.\nThen there\u0026rsquo;s unification. As everyone knows, Linux distributions are quite fragmented, even more fragmented than Android. I personally switched from arch to debian to opensuse back to debian and finally settled on fedora, and there are countless niche within niche distributions, while these distributions also have version fragmentation similar to Android. Then you also have to factor in desktop environment fragmentation: gnome/kde/cosmic/xfce/lxqt/.... This fragmentation brings a terrible user experience and has discouraged many developers.\nFinally, from the developer\u0026rsquo;s perspective, there have always been two contradictory points.\nFirst is the difference in system environment between developers and users, which is a fragmentation problem, but it has given Linux users a bad reputation, such as the common saying: the smallest number of users, but the most issues reported.\nSecond is with distributions, where the core contradiction lies in different requirements for dependency versions between distributions and developers. Distributions need a certain component to stay at the latest version or not update major versions, only updating security patches. Developers have one requirement: use the same dependency versions as the development environment.\nHow Does Flatpak Solve These Runtime The runtime encompasses most common base libraries, such as glibc, libstdc++, libcurl, xorg suite, wayland suite, etc. Version numbers like 23.08/24.08, with one major update per year to introduce breaking changes, while regular maintenance ensures ABI compatibility. Libraries not in the runtime are bundled by the software itself, and libraries with the same name prioritize loading the bundled version. Similar to the Win/Android approach. Runtime is divided into Platform and SDK. Simply put, Platform is derived from SDK by removing header files, static libraries, compilation toolchains, etc. Now that the basic situation is explained, some people may wonder why not directly use the host\u0026rsquo;s libraries, which would save more space.\nDecoupling from the system - not depending on or assuming the host system\u0026rsquo;s libraries, so that even an ancient Debian oldstable can use the latest libraries and software. This also greatly solves the distribution fragmentation problem.\nFor developers, a determined runtime environment, the freedom to decide dependency library versions, allows more energy to be focused on developing software.\nbubblewrap Isolation An unprivileged sandbox implemented through Linux namespaces, details can be found on the project homepage.\nIt ensures that, with specified limited permissions, flatpak applications are isolated from the host environment.\nPortal (xdp) After isolating the host environment, we need a set of verified IPC interfaces to manage some sensitive host resources.\nYou can refer to Android permissions, though Android is based on binder, while xdp is based on dbus.\nWhat\u0026rsquo;s quite interesting is that xdp has indirectly unified the chaotic desktop environment interfaces of Linux desktop. qt/gtk/electron/... have all now adapted to xdp.\nIs Flatpak a Package Manager Back to the article\u0026rsquo;s title, is Flatpak a package management tool? I don\u0026rsquo;t think so.\nOur definition of package management is generally limited to software within Linux distributions that satisfies certain functions. Flatpak has many similarities with these software, but the approach is completely different. Most importantly, Flatpak cannot replace traditional package management; it\u0026rsquo;s more of a supplement, returning package management to the role of \u0026ldquo;managing system software packages\u0026rdquo;. Flatpak packages have very coarse granularity and unusually shallow dependency relationships, unable to build/operate fine components in distributions. For example, freedesktop sdk itself is not built through Flatpak but through BuildStream.\nHowever, this is actually an open question, and readers can judge for themselves.\nOr look at it from another angle, for example, is Android\u0026rsquo;s package installer a package manager?\nFlatpak Tips and Technical Details Runtime /app Let\u0026rsquo;s go into the runtime and take a specific look\n$ flatpak run --command=bash org.freedesktop.Sdk//24.08 [ðŸ“¦ org.freedesktop.Sdk ~]$ ls / app bin dev etc lib lib64 proc run sbin sys tmp usr var [ðŸ“¦ org.freedesktop.Sdk ~]$ cat /etc/ld.so.conf include /run/flatpak/ld.so.conf.d/app-*.conf include /app/etc/ld.so.conf /app/lib include /run/flatpak/ld.so.conf.d/runtime-*.conf [ðŸ“¦ org.freedesktop.Sdk ~]$ ldd /usr/bin/ls linux-vdso.so.1 (0x00007f4737637000) libselinux.so.1 =\u0026gt; /usr/lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f47375bd000) libc.so.6 =\u0026gt; /usr/lib/x86_64-linux-gnu/libc.so.6 (0x00007f47373be000) libpcre2-8.so.0 =\u0026gt; /usr/lib/x86_64-linux-gnu/libpcre2-8.so.0 (0x00007f473731d000) /lib64/ld-linux-x86-64.so.2 (0x00007f4737639000) [ðŸ“¦ org.freedesktop.Sdk ~]$ echo $PATH /app/bin:/usr/bin You can see that this is actually equivalent to a minimal distribution following FHS.\n/app As the Prefix for each software, during compilation and packaging, only this directory is writable. /app/lib Where software places bundled libraries /app/bin In the container\u0026rsquo;s PATH environment variable by default, the software\u0026rsquo;s startup program needs to be installed/linked here host share [ðŸ“¦ org.freedesktop.Sdk ~]$ echo $XDG_DATA_DIRS /app/share:/usr/share:/usr/share/runtime/share:/run/host/user-share:/run/host/share [ðŸ“¦ org.freedesktop.Sdk ~]$ cat /etc/fonts/conf.d/50-flatpak.conf \u0026lt;?xml version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE fontconfig SYSTEM \u0026#34;fonts.dtd\u0026#34;\u0026gt; \u0026lt;fontconfig\u0026gt; \u0026lt;!-- This has to be first so it is written while building the runtime --\u0026gt; \u0026lt;cachedir\u0026gt;/usr/cache/fontconfig\u0026lt;/cachedir\u0026gt; \u0026lt;dir\u0026gt;/app/share/fonts\u0026lt;/dir\u0026gt; \u0026lt;!-- Then this so it is written when building the app --\u0026gt; \u0026lt;cachedir\u0026gt;/app/cache/fontconfig\u0026lt;/cachedir\u0026gt; \u0026lt;include ignore_missing=\u0026#34;yes\u0026#34;\u0026gt;/app/etc/fonts/local.conf\u0026lt;/include\u0026gt; \u0026lt;dir\u0026gt;/run/host/fonts\u0026lt;/dir\u0026gt; \u0026lt;dir\u0026gt;/run/host/local-fonts\u0026lt;/dir\u0026gt; \u0026lt;dir\u0026gt;/run/host/user-fonts\u0026lt;/dir\u0026gt; \u0026lt;!-- This is duplicated from the general config because we want to write there before the /run dirs, in case they are ever writable, like e.g with old versions of flatpak. --\u0026gt; \u0026lt;cachedir prefix=\u0026#34;xdg\u0026#34;\u0026gt;fontconfig\u0026lt;/cachedir\u0026gt; \u0026lt;cachedir\u0026gt;/run/host/fonts-cache\u0026lt;/cachedir\u0026gt; \u0026lt;cachedir\u0026gt;/run/host/user-fonts-cache\u0026lt;/cachedir\u0026gt; \u0026lt;include\u0026gt;/run/host/font-dirs.xml\u0026lt;/include\u0026gt; \u0026lt;/fontconfig\u0026gt; /run/host/share/icons Corresponds to /usr/share/icons\n/run/host/user-share/icons Corresponds to ${XDG_DATA_HOME}/icons\n/run/host/fonts Corresponds to /usr/share/fonts\n/run/host/user-fonts Corresponds to ${XDG_DATA_HOME}/fonts\nGlobal Permissions Flatpak can preset unified permissions for all applications. This is quite useful, for example, I have a folder that no application should see, even with host permission.\n$ flatpak override --user --filesystem=\u0026#39;xdg-config/fontconfig:ro\u0026#39; $ cat ~/.local/share/flatpak/overrides/global [Context] filesystems=xdg-config/gtk-3.0:ro;!xdg-run/keyring;/nix:ro;xdg-config/fontconfig:ro; [Session Bus Policy] com.canonical.AppMenu.Registrar=talk [Environment] MOZ_ENABLE_WAYLAND=1 Priority The application\u0026rsquo;s own permission configuration has first priority, followed by global permissions. However, filesystem permissions are a bit different, as they have their own priority. For example, host/home has lower priority than general paths. Roughly speaking, filesystem\u0026rsquo;s own priority is satisfied first before considering others.\nsystem-wide and per-user Similar to Windows\u0026rsquo; install for all users vs install just for me. Note that these two are completely independent, and if both are used, two copies of runtime are needed. I recommend using per-user, but if it\u0026rsquo;s a shared home computer, system-wide is recommended.\nsystem-wide Installation location: /var/lib/flatpak/ Requires permissions to execute commands, distributions basically all have polkit rule installed, of course you can also use sudo\nper-user Installation location: $HOME/.local/share/flatpak/ Requires using the --user flag, added after the command\n","permalink":"https://blog.bluempty.com/en/post/is-flatpak-package-manager/","summary":"\u003cblockquote\u003e\n\u003cp\u003eReading this article requires some understanding of: \u003ccode\u003eLinux distributions\u003c/code\u003e, \u003ccode\u003eLinux Desktop Environment\u003c/code\u003e, \u003ccode\u003ePackage Manager\u003c/code\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eMy first encounter with Linux was in high school, when there seemed to be a software that only had a Linux version, so I tried to install Arch by following online articles. I don\u0026rsquo;t remember the specific details anymore.\nFor me at that time, a bunch of incomprehensible commands were quite a headache, and I was always afraid of breaking my computer.\u003c/p\u003e","title":"Is Flatpak a Package Manager"}]