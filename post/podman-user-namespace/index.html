<!doctype html><html lang=zh dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>User Namespace 套娃 | Bluempty</title>
<meta name=keywords content="linux"><meta name=description content="博主已经用了 podman 很长一段时间，老实说有个概念一直一知半解，就是 User Namespace，以及其相关的配置选择
就是处于试一试，能用就这样的心态，也就一直安然无恙的用下来了
但是稍微复杂点的需求，这样半吊子就跑不起来了，遂稍微看看是个什么玩意"><meta name=author content="hypengw"><link rel=canonical href=https://blog.bluempty.com/post/podman-user-namespace/><link crossorigin=anonymous href=/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as=style><link rel=icon href=https://blog.bluempty.com/images/profile.webp><link rel=icon type=image/png sizes=16x16 href=https://blog.bluempty.com/images/profile.webp><link rel=icon type=image/png sizes=32x32 href=https://blog.bluempty.com/images/profile.webp><link rel=apple-touch-icon href=https://blog.bluempty.com/apple-touch-icon.png><link rel=mask-icon href=https://blog.bluempty.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://blog.bluempty.com/post/podman-user-namespace/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=/css/dimbox.min.css><meta property="og:url" content="https://blog.bluempty.com/post/podman-user-namespace/"><meta property="og:site_name" content="Bluempty"><meta property="og:title" content="User Namespace 套娃"><meta property="og:description" content="博主已经用了 podman 很长一段时间，老实说有个概念一直一知半解，就是 User Namespace，以及其相关的配置选择
就是处于试一试，能用就这样的心态，也就一直安然无恙的用下来了
但是稍微复杂点的需求，这样半吊子就跑不起来了，遂稍微看看是个什么玩意"><meta property="og:locale" content="zh-hans"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2025-10-24T23:11:24+08:00"><meta property="article:modified_time" content="2025-10-24T23:11:24+08:00"><meta property="article:tag" content="Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="User Namespace 套娃"><meta name=twitter:description content="博主已经用了 podman 很长一段时间，老实说有个概念一直一知半解，就是 User Namespace，以及其相关的配置选择
就是处于试一试，能用就这样的心态，也就一直安然无恙的用下来了
但是稍微复杂点的需求，这样半吊子就跑不起来了，遂稍微看看是个什么玩意"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://blog.bluempty.com/post/"},{"@type":"ListItem","position":2,"name":"User Namespace 套娃","item":"https://blog.bluempty.com/post/podman-user-namespace/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"User Namespace 套娃","name":"User Namespace 套娃","description":"博主已经用了 podman 很长一段时间，老实说有个概念一直一知半解，就是 User Namespace，以及其相关的配置选择\n就是处于试一试，能用就这样的心态，也就一直安然无恙的用下来了\n但是稍微复杂点的需求，这样半吊子就跑不起来了，遂稍微看看是个什么玩意\n","keywords":["linux"],"articleBody":"博主已经用了 podman 很长一段时间，老实说有个概念一直一知半解，就是 User Namespace，以及其相关的配置选择\n就是处于试一试，能用就这样的心态，也就一直安然无恙的用下来了\n但是稍微复杂点的需求，这样半吊子就跑不起来了，遂稍微看看是个什么玩意\n一些简单背景 众说周知，user 这个概念是 system 给的，对应到接口上，就是 uid/gid 以及内部与其绑定的子系统，通过这些来进行权限判断和访问控制\n同时，构建在 kernel 之上的 system 还需要将 user 和 filesystem 绑定在一起，用于描述 user 和 file 之间的关系，以及某些 file 在 kernel 那边的特殊处理\n传统上 [0,65535] 为系统保留的 uid 范围，而这其中 0 为 root，大于 65535 的可以被拿去做 uid_map\n顺带一提，Linux 发行版新建普通 user 时，uid 常见都是从 1000 开始分配的\nuser_namespaces A process’s user and group IDs can be different inside and outside a user namespace User namespaces can be nested When a user namespace is created, it starts out without a mapping of user IDs (group IDs) to the parent user namespace. The /proc/pid/uid_map and /proc/pid/gid_map files (available since Linux 3.5) expose the mappings for user and group IDs inside the user namespace for the process pid After the creation of a new user namespace, the uid_map file of one of the processes in the namespace may be written to once to define the mapping of user IDs in the new user namespace Since Linux 3.8, no privilege is required to create a user namespace kernel api: clone, setns, unshare, ioctl Rootless Containers Rootless containers refers to the ability for an unprivileged user to create, run and otherwise manage containers. This term also includes the variety of tooling around containers that can also be run as an unprivileged user.\n“Unprivileged user” in this context refers to a user who does not have any administrative rights, and is “not in the good graces of the administrator” (in other words, they do not have the ability to ask for more privileges to be granted to them, or for software packages to be installed).\nPros:\n- Can mitigate potential container-breakout vulnerabilities (Not a panacea, of course)\n- Friendly to shared machines, especially in HPC environments Cons:\n- Complexity\npodman rootless Podman can also be used as non-root user. When podman runs in rootless mode, a user namespace is automatically created for the user, defined in /etc/subuid and /etc/subgid.\n可以见得，podman 的 rootless 就是 continaer with user namespace\n我们简单看看默认情况下的 userns 的情况\n$ cat /etc/subuid my:100000:65536 $ readlink /proc/self/ns/user user:[4026531837] $ cat /proc/self/uid_map 0 0 4294967295 $ podman run --rm -it docker.io/library/ubuntu:latest bash root@e8d3045e9019:/# readlink /proc/self/ns/user user:[4026533265] root@e8d3045e9019:/# cat /proc/self/uid_map 0 1000 1 1 100000 65536 这里我们先看了当前 shell 所在的 userns，即 host 里的初始 userns 这时 uid_map 显示的是没有任何 map 的状态\n而进入 rootless container 后，userns 发生了变化，同时 uid_map 如下\nnamespace uid outside uid count 0 1000 1 1 100000 65536 即将 当前用户的 uid 1000 映射到容器里的 0(root)，而之后的容器的 uid 从外部的 100000 开始分配\n$ lsns -t user -o NS,PNS,TYPE NS PNS TYPE 4026531837 0 user 4026533265 4026531837 user 通过 lsns 我们可以看到，容器的 userns 的 parent ns 是 host 的初始 userns\npodman rootless userns 套娃 这里就要说 podman userns 相关的配置选项了，主要是 --userns 和 --uidmap\n其实两者本质是相同的，对底层的 container runtime 来说\n都是在上面说的 container 第一层的 userns 下再套了一层 userns\n这时 podman 把第一层的 userns 的 uid 称为 intermediate UID\n文档里的路径为 host UID -\u003e intermediate UID -\u003e container UID，但其实没有什么特殊的，就是上层的 userns 而已\n--userns=mode Key Host User Container User auto $UID nil (Host User UID is not mapped into container.) host $UID 0 (Default User account mapped to root user in container.) keep-id $UID $UID (Map user account to same UID within container.) keep-id:uid=200,gid=210 $UID 200:210 (Map user account to specified UID, GID value within container.) nomap $UID nil (Host User UID is not mapped into container.) note\n这里的 nomap 还是会创建二层 userns，反而是 host 和默认的行为一致，只有一层 userns\n--uidmap=[flags]container_uid:from_uid[:amount] 上面的 --userns 都可以改为一些 --uidmap 的组合\nKey Uidmap keep-id --uidmap=0:1:1000 --uidmap=1000:0:1 --uidmap=1001:1001:64536 nomap --uidmap=0:1:65536 ","wordCount":"1065","inLanguage":"zh","datePublished":"2025-10-24T23:11:24+08:00","dateModified":"2025-10-24T23:11:24+08:00","author":{"@type":"Person","name":"hypengw"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.bluempty.com/post/podman-user-namespace/"},"publisher":{"@type":"Organization","name":"Bluempty","logo":{"@type":"ImageObject","url":"https://blog.bluempty.com/images/profile.webp"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://blog.bluempty.com/ accesskey=h title="Bluempty (Alt + H)">Bluempty</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://blog.bluempty.com/en/ title=En aria-label=En>En</a></li></ul></div></div><ul id=menu><li><a href=https://blog.bluempty.com/archives/ title=归档><span>归档</span></a></li><li><a href=https://blog.bluempty.com/tags/ title=标签><span>标签</span></a></li><li><a href=https://blog.bluempty.com/search/ title=搜索><span>搜索</span></a></li><li><a href=https://blog.bluempty.com/friends/ title=友链><span>友链</span></a></li><li><a href=https://blog.bluempty.com/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://blog.bluempty.com/>主页</a>&nbsp;»&nbsp;<a href=https://blog.bluempty.com/post/>Posts</a></div><h1 class="post-title entry-hint-parent">User Namespace 套娃</h1><div class=post-meta><span title='2025-10-24 23:11:24 +0800 +0800'>十月 24, 2025</span>&nbsp;·&nbsp;3 分钟&nbsp;·&nbsp;hypengw</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><ul><li><a href=#%e4%b8%80%e4%ba%9b%e7%ae%80%e5%8d%95%e8%83%8c%e6%99%af aria-label=一些简单背景>一些简单背景</a><ul><li><a href=#user_namespaceshttpsman7orglinuxman-pagesman7user_namespaces7html aria-label=user_namespaces>user_namespaces</a></li><li><a href=#rootless-containershttpsrootlesscontainers aria-label="Rootless Containers">Rootless Containers</a></li></ul></li><li><a href=#podman-rootless aria-label="podman rootless">podman rootless</a></li><li><a href=#podman-rootless-userns-%e5%a5%97%e5%a8%83 aria-label="podman rootless userns 套娃">podman rootless userns 套娃</a><ul><li><a href=#--usernsmode aria-label="--userns=mode">--userns=mode</a></li><li><a href=#--uidmapflagscontainer_uidfrom_uidamount aria-label="--uidmap=[flags]container_uid:from_uid[:amount]">--uidmap=[flags]container_uid:from_uid[:amount]</a></li></ul></li></ul></div></details></div><div class=post-content><p>博主已经用了 podman 很长一段时间，老实说有个概念一直一知半解，就是 User Namespace，以及其相关的配置选择<br>就是处于试一试，能用就这样的心态，也就一直安然无恙的用下来了<br>但是稍微复杂点的需求，这样半吊子就跑不起来了，遂稍微看看是个什么玩意</p><h2 id=一些简单背景>一些简单背景<a hidden class=anchor aria-hidden=true href=#一些简单背景>#</a></h2><p>众说周知，user 这个概念是 system 给的，对应到接口上，就是 <code>uid</code>/<code>gid</code> 以及内部与其绑定的子系统，通过这些来进行权限判断和访问控制<br>同时，构建在 kernel 之上的 system 还需要将 user 和 filesystem 绑定在一起，用于描述 user 和 file 之间的关系，以及某些 file 在 kernel 那边的特殊处理<br>传统上 <code>[0,65535]</code> 为系统保留的 <code>uid</code> 范围，而这其中 <code>0</code> 为 <code>root</code>，大于 <code>65535</code> 的可以被拿去做 <code>uid_map</code><br>顺带一提，Linux 发行版新建普通 user 时，<code>uid</code> 常见都是从 <code>1000</code> 开始分配的</p><h3 id=user_namespaceshttpsman7orglinuxman-pagesman7user_namespaces7html><a href=https://man7.org/linux/man-pages/man7/user_namespaces.7.html>user_namespaces</a><a hidden class=anchor aria-hidden=true href=#user_namespaceshttpsman7orglinuxman-pagesman7user_namespaces7html>#</a></h3><ul><li>A process&rsquo;s user and group IDs can be different inside and outside a user namespace</li><li>User namespaces can be nested</li><li>When a user namespace is created, it starts out without a mapping of user IDs (group IDs) to the parent user namespace. The <code>/proc/pid/uid_map</code> and <code>/proc/pid/gid_map</code> files (available since Linux 3.5) expose the mappings for user and group IDs inside the user namespace for the process pid</li><li>After the creation of a new user namespace, the uid_map file of one of the processes in the namespace may be written to once to define the mapping of user IDs in the new user namespace</li><li>Since Linux 3.8, no privilege is required to create a user namespace</li><li>kernel api: <code>clone</code>, <code>setns</code>, <code>unshare</code>, <code>ioctl</code></li></ul><h3 id=rootless-containershttpsrootlesscontainers><a href=https://rootlesscontaine.rs/>Rootless Containers</a><a hidden class=anchor aria-hidden=true href=#rootless-containershttpsrootlesscontainers>#</a></h3><p>Rootless containers refers to the ability for an unprivileged user to create, run and otherwise manage containers. This term also includes the variety of tooling around containers that can also be run as an unprivileged user.</p><p>“Unprivileged user” in this context refers to a user who does not have any administrative rights, and is “not in the good graces of the administrator” (in other words, they do not have the ability to ask for more privileges to be granted to them, or for software packages to be installed).</p><p>Pros:<br>- Can mitigate potential container-breakout vulnerabilities (Not a panacea, of course)<br>- Friendly to shared machines, especially in HPC environments
Cons:<br>- Complexity</p><h2 id=podman-rootless>podman rootless<a hidden class=anchor aria-hidden=true href=#podman-rootless>#</a></h2><blockquote><p>Podman can also be used as non-root user. When podman runs in rootless mode, a user namespace is automatically created for the user, defined in <code>/etc/subuid</code> and <code>/etc/subgid</code>.</p></blockquote><p>可以见得，podman 的 rootless 就是 continaer with user namespace</p><p>我们简单看看默认情况下的 userns 的情况</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ cat /etc/subuid       
</span></span><span class=line><span class=cl>my:100000:65536
</span></span><span class=line><span class=cl>$ readlink /proc/self/ns/user  
</span></span><span class=line><span class=cl>user:<span class=o>[</span>4026531837<span class=o>]</span>
</span></span><span class=line><span class=cl>$ cat /proc/self/uid_map 
</span></span><span class=line><span class=cl>         <span class=m>0</span>          <span class=m>0</span> <span class=m>4294967295</span>
</span></span><span class=line><span class=cl>$ podman run --rm -it docker.io/library/ubuntu:latest bash
</span></span><span class=line><span class=cl>root@e8d3045e9019:/# readlink /proc/self/ns/user
</span></span><span class=line><span class=cl>user:<span class=o>[</span>4026533265<span class=o>]</span>
</span></span><span class=line><span class=cl>root@e8d3045e9019:/# cat /proc/self/uid_map 
</span></span><span class=line><span class=cl>         <span class=m>0</span>       <span class=m>1000</span>          <span class=m>1</span>
</span></span><span class=line><span class=cl>         <span class=m>1</span>     <span class=m>100000</span>      <span class=m>65536</span>
</span></span></code></pre></div><p>这里我们先看了当前 shell 所在的 userns，即 host 里的初始 userns
这时 <code>uid_map</code> 显示的是没有任何 map 的状态<br>而进入 rootless container 后，userns 发生了变化，同时 <code>uid_map</code> 如下</p><table><thead><tr><th style=text-align:left>namespace uid</th><th style=text-align:left>outside uid</th><th style=text-align:left>count</th></tr></thead><tbody><tr><td style=text-align:left>0</td><td style=text-align:left>1000</td><td style=text-align:left>1</td></tr><tr><td style=text-align:left>1</td><td style=text-align:left>100000</td><td style=text-align:left>65536</td></tr></tbody></table><p>即将 当前用户的 uid <code>1000</code> 映射到容器里的 <code>0(root)</code>，而之后的容器的 uid 从外部的 <code>100000</code> 开始分配</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ lsns -t user -o NS,PNS,TYPE
</span></span><span class=line><span class=cl>        NS        PNS TYPE
</span></span><span class=line><span class=cl><span class=m>4026531837</span>          <span class=m>0</span> user
</span></span><span class=line><span class=cl><span class=m>4026533265</span> <span class=m>4026531837</span> user
</span></span></code></pre></div><p>通过 <code>lsns</code> 我们可以看到，容器的 userns 的 parent ns 是 host 的初始 userns</p><h2 id=podman-rootless-userns-套娃>podman rootless userns 套娃<a hidden class=anchor aria-hidden=true href=#podman-rootless-userns-套娃>#</a></h2><p>这里就要说 podman userns 相关的配置选项了，主要是 <code>--userns</code> 和 <code>--uidmap</code><br>其实两者本质是相同的，对底层的 container runtime 来说<br>都是在上面说的 container 第一层的 userns 下再套了一层 userns<br>这时 podman 把第一层的 userns 的 uid 称为 <code>intermediate UID</code><br>文档里的路径为 <code>host UID -> intermediate UID -> container UID</code>，但其实没有什么特殊的，就是上层的 userns 而已</p><h3 id=--usernsmode><code>--userns=mode</code><a hidden class=anchor aria-hidden=true href=#--usernsmode>#</a></h3><table><thead><tr><th style=text-align:left>Key</th><th style=text-align:left>Host User</th><th style=text-align:left>Container User</th></tr></thead><tbody><tr><td style=text-align:left>auto</td><td style=text-align:left>$UID</td><td style=text-align:left>nil (Host User UID is not mapped into container.)</td></tr><tr><td style=text-align:left>host</td><td style=text-align:left>$UID</td><td style=text-align:left>0 (Default User account mapped to root user in container.)</td></tr><tr><td style=text-align:left>keep-id</td><td style=text-align:left>$UID</td><td style=text-align:left>$UID (Map user account to same UID within container.)</td></tr><tr><td style=text-align:left>keep-id:uid=200,gid=210</td><td style=text-align:left>$UID</td><td style=text-align:left>200:210 (Map user account to specified UID, GID value within container.)</td></tr><tr><td style=text-align:left>nomap</td><td style=text-align:left>$UID</td><td style=text-align:left>nil (Host User UID is not mapped into container.)</td></tr></tbody></table><blockquote><p>note<br>这里的 nomap 还是会创建二层 userns，反而是 host 和默认的行为一致，只有一层 userns</p></blockquote><h3 id=--uidmapflagscontainer_uidfrom_uidamount><code>--uidmap=[flags]container_uid:from_uid[:amount]</code><a hidden class=anchor aria-hidden=true href=#--uidmapflagscontainer_uidfrom_uidamount>#</a></h3><p>上面的 <code>--userns</code> 都可以改为一些 <code>--uidmap</code> 的组合</p><table><thead><tr><th style=text-align:left>Key</th><th style=text-align:left>Uidmap</th></tr></thead><tbody><tr><td style=text-align:left>keep-id</td><td style=text-align:left><code>--uidmap=0:1:1000 --uidmap=1000:0:1 --uidmap=1001:1001:64536</code></td></tr><tr><td style=text-align:left>nomap</td><td style=text-align:left><code>--uidmap=0:1:65536</code></td></tr></tbody></table></div><footer class=post-footer><ul class=post-tags><li><a href=https://blog.bluempty.com/tags/linux/>Linux</a></li></ul><nav class=paginav><a class=prev href=https://blog.bluempty.com/post/to-yourself/><span class=title>« 上一页</span><br><span>对自己好点</span>
</a><a class=next href=https://blog.bluempty.com/post/signal-and-vector-gaussian/><span class=title>下一页 »</span><br><span>信号与向量: 高斯模糊</span></a></nav></footer></article></main><footer class=footer><span>© 2025 <a href=https://blog.bluempty.com>Bluempty</a> · <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script src=/js/dimbox.min.js></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>